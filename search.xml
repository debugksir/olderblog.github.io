<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[node.js学习笔记三]]></title>
      <url>%2F2017%2F01%2F06%2Fnode-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
      <content type="text"><![CDATA[node.js 学习笔记三 node.js的事件循环机制 Node.js 在什么时候会进入事件循环呢？答案是 Node.js 程序由事件循环开始，到事件循环结束，所有的逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或直接发射（emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未处理的事件，直到程序结束 事件循环 –&gt; 回调函数 –&gt; 磁盘I/O/网络通信/数据库查询 –&gt; 时间循环队列 –&gt; 事件循环 –&gt; 回调函数 模板和包 模块（Module）和包（Package）是 Node.js 最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、封装，然后组合起来，模块正是为了实现这种方式而诞生的。模板都是基于文件的,机制很简单.可以把包理解为实现了某个功能的模块的集合 什么是模块 模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。 创建模块 在 Node.js 中，创建一个模块非常简单，因为一个文件就是一个模块，我们要关注的问题仅仅在于如何在其他文件中获取这个模块。Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 新建一个module.js文件 var name; exports.setName = function(thyname) { name = thyname; }; exports.sayHello = function(){ console.log('hello! ' + name + ' how are you ! '); }; 新建一个getModule.js文件 var ksir = require('./module'); ksir.setName('ksir'); ksir.sayHello(); 不管getModule.js调用module模块多少次,只会加载一次 创建包 包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java/.Net的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根据 CommonJS 规范实现了包机制，开发了 npm来解决包的发布和获取需求。Node.js 的包是一个目录，其中包含一个 JSON 格式的包说明文件 package.json。严格符合 CommonJS 规范的包应该具备以下特征: package.json 必须在包的顶层目录下； 二进制文件应该在 bin 目录下； JavaScript 代码应该在 lib 目录下； 文档应该在 doc 目录下； 单元测试应该在 test 目录下。 在写包的时候,尽量按照 CommonJS 的规范 一个模块除了是一个js文件外,还可以是一个文件夹 //somepackage/index.js exports.hello = function() { console.log('Hello.'); }; 然后在 somepackage 之外建立 getpackage.js，内容如下： //getpackage.js var somePackage = require('./somepackage'); somePackage.hello(); 此外,还可以将目标文件放在lib文件内,将该地址放在package.json文件中的main键值中 { "main" : "./lib/interface.js" } 3 创建全局链接 我们用npm安装的全局包是不能够被我们require到的,只有本地安装的包才可以,当我们的系统原来安装了全局包,可以通过npm link [packageName] 来移植到node_modules中.不过改名了在window系统是不受支持]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node.js学习笔记二]]></title>
      <url>%2F2017%2F01%2F04%2Fnode-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[Node.js同步与异步 Node.js最大的特性就是异步式I/O与事件紧密结合的编程模式。这种模式与传统的同步式IO线性的编程思路有很大的不同，因为控制流很大程度上要靠事件和回调函数来组织，一个逻辑要拆分为若干个单元格。 内容：阻塞和线程 同步式I/O或阻塞式I/O 线程在执行中如果遇到磁盘读写或网络通信，通常要耗费较长时间。这时操作系统会剥夺这个线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式成为阻塞，当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权、令其继续执行。 异步式I/O或非阻塞式I/O 针对所有I/O操作不采用阻塞策略，当线程遇到I/O操作时，不会以阻塞的方式等待I/O操作的完成或数据的返回，而只是讲IO请求发送给操作系统，继续执行下一条语句，当操作系统完成IO操作时，以事件的形式通知执行IO操作的线程，线程会在特定时候处理这个事件，为了 处理异步IO，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。 非阻塞与阻塞模式区别 非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的CPU核心利用率永远是100%，IO以事件的方式通知。阻塞模式下，多线程往往能提高系统吞吐量，因为一个线程阻塞还有其他线程在工作，多线程可以让CPU资源不被阻塞中的线程浪费。调度：当前一个工作,在5分钟之后执行 同步式IO与异步式IO区别 同步式IO(阻塞式) 利用多线程提供吞吐量 通过事件片分割和线程调度利用多核CPU 需要由操作系统调度多线程使用多核CPU 难以充分利用CPU资源 内存轨迹大,数据局部性弱 异步式IO(非阻塞) 单线程即可实现高吞吐量 通过功能划分利用多核 可以将单线程绑定到单核CPU 可以充分利用CPU资源 内存轨迹小,数据局部性强 资源出处 silvercell的博客 感谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node.js学习笔记一]]></title>
      <url>%2F2017%2F01%2F01%2Fnode-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
      <content type="text"><![CDATA[Node.js学习笔记一 Node.js 是什么 Node.js 不是一门独立的语言,不是Javascript的框架,不是浏览器的库,Node.js是一个让Javascript运行在服务器的开发平台 Node.js 能做什么 Javascript是由客户端而产生,Node.js为网络而生 实现复杂逻辑的网站 基于社交网络的大WEB的应用 Web Socket服务器 TCP/UDP套接字应用程序 命令行工具 交互式终端程序 异步式I/O与事件驱动 Node.js 最大的特点就是采用异步式I/O与事件驱动的架构设计. 对于高并发的解决方案,传统的架构是多线程模式,也就是每个业务逻辑提供一个系统线程,通过系统线程切换来弥补同步式I/O调用时的时间开销. Node.js使用的单线程模式,在执行的过程中会维护一个事件队列,程序在执行时再进入事件循环等待下一个事件的到来 浏览器的引擎拾贝 为什么Ext.js在Chrome浏览器上运行如此快,Chrome浏览器与Node.js浏览器的引擎同为V8传统: 浏览器-&gt;Apache/IIS/Nginx/Tomcat-&gt;php/c#/java/python; node: 浏览器-&gt;node.js Node.js环境的安装 打开网址nodjs.org下载对应系统的安装包, 打开命令提示符cmd 输入node -v 查看版本,查看是否安装成功,输入node进入编译模式,执行一段js代码比如console.log(&#39;hello world&#39;)体验一番 Node.js初体验使用node.js开启服务 var http = require(‘http’);http.createServer(function(req,res){ res.writeHead(200,{‘Content-Type’:’text/html’}); res.write(‘hello world!‘); res.end(‘我是nodejs服务器‘);}).listen(3000);我们可以通过在浏览器打开localhost:3000查看结果 为了方便以后测试, 我们可以安装一个supervisor插件来监听我们的代码调试]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2017%2F01%2F01%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[正则表达式笔记常用的元字符 . 匹配除换行符意外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 如果你想要匹配的字符跟元字符重叠,此时需要用到转义字符,在需要的匹配的字符前加\,比如使用\.和\*。当然，要查找\本身，你也得用\\ 常用的限定符 * 重复0或多次 + 重复1或多次 ? 重复-或1次 {n} 重复n次 {n,m} 重复n到m次 字符类 [adfsd] 匹配其中任何一个字母 [0-9] 字符范围,含义与\d 完全一致 看个例子 \(?0\d{2}[)-]?\d{8} 这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。 分支条件 对于在多个条件中,只要满足任意一个就满足的话可以用 | 将不同的的规则分开 看几个例子: 0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。 分组 我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。(\d{1,3}\.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。 反义 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aefsdf] 匹配除了aefsdf这几个字母以外的任意字符 后向引用 使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。 你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?&lt;Word&gt;\w+)(或者把尖括号换成’也行：(?&#39;Word&#39;\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k&lt;Word&gt;,所以上一个例子也可以写成这样：\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b。 常用的捕获分组语法 (exp) 匹配exp,并捕获文本到自动命名的组里 (?&lt;name&gt;exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp) (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。 常用的零宽断言 (?=exp) 匹配exp前面的位置 (?&lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?!&lt;exp) 匹配前面不是exp的位置 注释 小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样： (?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB-shell命令]]></title>
      <url>%2F2016%2F11%2F06%2FMongoDB-shell%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[MongoDB shell 常用命令 关系数据的表的record 必须拥有field,mongoDB的一行数据以文档(document) 的形式,相在关系数据库中是一条记录,mongoDB的key可以不一样,在关系数据库中查询使用SQL,在mongoDB中使用find函数-&gt;基于BSON的特殊查询工具,mongodb的灵活度扩展度极高 创建一个.bat格式的文件,在文件中输入mongo --dbpath 文件路径,创建一个开设端口的.bat格式文件,在文件中输入mongo 127.0.0.1:27017/admin 分别打开即可开启数据库 创建一个数据库 use[datebase] 插入文档 db.[documentName].insert({}) 查看所有数据库 show dbs 查看数据库中所有文档 show collections 查询文档数据 db.[documentName].find() 查询一条 db.[documentNmae].findOne() 批量插入文档 1. 用mongo的应用驱动. 2.shell的for循环 删除列表中的所有数据 db.[documentName].remove() 根据条件删除 db.text.remove({name: &quot;ksir&quot;}) 删除库中的集合 db.[documentName].drop() 删除数据库 db.dropDatabase() 显示帮助 数据库下的帮助:db.help(),集合下的帮助:db.[documentName].help() mongoDB的API http://api.mongodb.org 强硬的文档替换式更新操作 db.[documentName].update({查询器},{修改器}) 显示数据库状态 db.stats() 主键冲突的时候会报错并且停止更新操作 insertOrUpdate 操作 如果存在数据就执行更新操作,否则执行插入操作 db.[documentName]({查询器},{修改器},true) 批量更新操作 当查修多条数据的时候默认修改第一条数据,如何批量修改数据: db.[documentName].update({查询器},{修改器},false,true) $addToSet与$each 结合完成批量数组更新 db.text.update({_id:100},{$addToSet:{books:{$each:[&quot;JS&quot;,&quot;HTML&quot;,&quot;CSS&quot;,&quot;DB&quot;]}}}) 数据库和集合的命名规范 不能是空字符串;不能含有’’,空格,$,/,\等;应全部小写;最多64个字节;不能与数据保留库名同名如”admin”,”local”,”config”; mongoDB 的shell内置Javascript引擎,可以直接执行js代码;shell可以使用eval]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[wamp的安装和环境配置]]></title>
      <url>%2F2016%2F03%2F13%2Fwamp%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[wamp的安装和环境配置wamp的简单介绍 Windows+Apache+Mysqul++PHP的首字母组合,集成安装环境,windows下的apache,php和mysql的服务器软件 wamp的安装 注意必需安装在没有中文文件名的目录下 安装好后我们可以在浏览器中输入127.0.0.1查看是否安装成功 为了能让更多域名来访问我们的服务器,我们需要对wamp安装目录下的bin下的apache下的Apache版本下的canf下的httpd.conf进行响应配置,这里我以自己的安装目录为例 C:\wamp\bin\apache\Apache2.2.21\conf\httpd.conf 在第235 行添加 Allow from all ,打开服务器的访问权限 如何修改成我们指定的根目录呢? 在httpd.conf文件的第178和205行把我们指定的根目录文件拷贝过来 如何实现对多个网站的管理呢? 在httpd.conf第467行找到virtual hosts下面的include, 把include前面的#号去掉,即打开注释,然后在C:\wamp\bin\apache\Apache2.2.21\conf\extra\httpd-vhosts.conf 中对DocumentRoot “E:/www/example”ServerName “example.com”ServerAlias “www.example.com”三项修改即可,注意修改之后须重启服务器才能生效 如何对DNS(ip域名映射关系)进行设置呢? 在C:\Windows\System32\drivers\etc\hosts下,将hosts文件拷贝出来,把127.0.0.1指定成你想要的域名地址,然后将原来的hosts文件覆盖即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数的四种调用模式]]></title>
      <url>%2F2016%2F03%2F13%2F%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[函数的四种调用模式 普通函数执行 this=&gt;window (声明一个函数后就直接调用) 12345function foo()&#123; console.log(1); console.log(this === window);&#125;foo(); 方法调用 this=&gt;该方法的调用者 (通过一个对象来调用方法) 1234567var obj = &#123; sayHi: function()&#123; console.log(&apos;hello,ksir.&apos;); console.log(this === obj); &#125;&#125;;obj.sayHi(); 构造函数模式 this=&gt;当前要创建出来的实例(对象) (配合new操作符来调用函数) 12345function fn(name)&#123; this.name = name; console.log(this);&#125;var ksir = new fn(&apos;ksir&apos;); call/apply模式(上下文模式) this=&gt;使用动态指定的 (指定call 或者 apply 方法的第一个参数) 区别: call 的参数大于等于2 , 第一个以后的为实参列表 apply 的参数只有两个,第二个是实参数组 注意:在非严格模式下,如果thisObj 赋值为null或者不传实参,此时this-&gt;window对象,就相当于普通函数执行模式 12345678910111213141516171819//只有函数对象才有call和apply方法//&lt;fn&gt;.call()//动态指定某方法或函数执行时内部this指向//A:&lt;fn&gt;.call(thisObj,arg1,arg2,...argN)//thisObj: 是fn在执行时this指向//arg1,arg2,...,argN: 是fn在执行时传入的实参列表function fn(name,age,gender)&#123; this.name = name; this.age = age; this.gender = gender; console.log(this);&#125;var ksir = new fn(&apos;ksir&apos;);var o = &#123;&#125;;fn.call(o,&apos;o&apos;,18,&apos;man&apos;);console.log(o.name);console.log(Function.prototype); 1234567891011//B:&lt;fn&gt;.apply(thisObj,[fn实参])function foo(name,age,gender)&#123; this.name = name; this.age = age; this.gender = gender;&#125;var ksir = &#123;&#125;;foo.apply(ksir,[&apos;ksir&apos;,21,&apos;男&apos;]);console.log(ksir.name);console.log(ksir.age);console.log(ksir.gender); 上下文模式的应用 数组合并 12345678910111213141516171819var arr1 = [1,2,3];var arr2 = [4,5,6];//数组合并,将arr2上的元素合并到arr1中//方法一for(var i,l = arr2.length; i&lt;l;i++)&#123; arr1.push(arr2[i]);&#125;console.log(arr1);//方法二var new arr = arr1.concat(arr2);//方法三arr1.push.apply(arr1,arr2);//[].push.apply(arr1,arr2);//Array.prototype.push.apply(arr1,arr2);console.log(arr1);console.log(arr1); 借调方法(函数) 12345678910111213141516171819function parent(name,age,gender)&#123; this.name = name; this.age = age; this.gender = gender;&#125;function child(name,age,gender,address)&#123; //对象冒充方法 //this.parent = parent; //this.parent(name,age,gender); //this.address = address; //delete this.parent; parent.call(this,name,age,gender); this.address = address;&#125;dvar ksir = new child(&apos;ksir&apos;,21,&apos;man&apos;,&apos;hunan&apos;);console.log(c); 数组去重 实现思路: 声明一个函数实现数组去重,取名为unique; 判断浏览器是否支持数组的indexOf方法 如果不支持,就实现数组的indexOf方法,并且将其扩展到数组的原型对象上 遍历数组,首先判断结果数组ret中是否含有当前遍历到的元素 如果没有,就将当前元素添加到ret中 循环结束,将ret返回 面试题12345678910111213141516function foo()&#123; getName = function() &#123; alert(1);&#125;; return this;&#125;foo.getName = function() &#123; alert(2);&#125;;foo.prototype.getName = function() &#123; alert(3); &#125;;var getName = function()&#123; alert(4);&#125;;function getName() &#123; alert(5); &#125;foo.getName();getName();foo().getName();getName();new foo.getName();new foo().getName();new new f00().getName();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[less环境配置]]></title>
      <url>%2F2016%2F03%2F08%2Fless%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[less环境配置less的简单介绍 less是基于nodejs的一种工具,能够实现对css的预编译,提高css可维护性 命令提示符下对less的编译 安装node.js (查看是否安装好node,在命令提示符中写入node -v) 打开命令提示符 (win+r) 在node环境下安装less (npm install less -g) 检查是否安装成功(lessc -v) 如何在命令提示符中完成less文件对css的转换 cd到你的less文件目录 输入命令: lessc less文件名.less 转换成css的文件名.css 利用sublime编译器完成对less的编译 打开sublime 快捷键 ctr+shift+p 输入install package 回车 安装less lessc 和less2css 3个插件 在命令提示符中安装这个插件: npm install less-plugin-clean-css -g 打开sublime首选项(preferences)中的package setting可以看到多了less 和 less2css 可以对less2css的setting-default拷贝,粘贴到setting-user中 修改配置来满足自己的需求]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gulp笔记]]></title>
      <url>%2F2016%2F02%2F10%2Fgulp%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[gulp 学习笔记 确认在安装gulp工具前已安装nodeJS环境 打开命令提示符,执行 npm install gulp -g cd 到目录下 npm install gulp 在项目中创建 gulpfile.js 在项目文件中配置 gulpfile.js 来支配 gulp 如何工作 gulp 是总指挥,不参与具体的实现,通过调用gulp的插件,这些插件都是基于nodejs的 插件安装 npm install gulp-cssmin ;插件安装 npm install gulp-autoperfixer 等等…(每使用一个gulp插件,都需要在命令行执行相应的安装命令) 项目构建几个文件的功能描述 所有的插件都记录在package.json里面,别人使用 npm install 安装所用插件 bower.json 记录了引入的代码框架 .gitinore 文件用于忽略 git 上传文件 ×××-manifest.json 文件记录着修改过的文件信息 规范化项目文件目录 api 存放接口文件 libs 存放框架 public 存放 CSS 样式,字体,图片 script 存放 JS 文件 uploads 存放交互图片 views 存放视图模板 rev 存放文件修改记录文件 release 存放测试项目 .git git 初始化而来文件 bower_components 工具 bower 引入框架配置文件 node_modules gulp 初始化而来的文件 gulpfile.js 例子 var gulp = require('gulp'); // 引入包 var gulp-autoperfixer 添加 CSS 私有前缀 var less = require('gulp-less'); // CSS预处理 var rev = require('gulp-rev'); // 添加版本号 var imagemin = require('gulp-imagemin'); // 压缩图片 var rename = require('gulp-rename'); // 重命名 var useref = require('gulp-useref'); // 记录文件修改信息 var gulpif = require('gulp-if'); // 判断 var uglify = require('gulp-ugligy'); // 压缩 Javascript var revCollector = require('gulp-rev-collector'); 内容置换 // 处理css gulp.task('css',function(){ return gulp.src('./public/less/main.less') .pipe(less()) .pipe(rev()) // 修改 css 名字 .pipe(gulp.dest('./release/public/css')) .pipe(rev.manifest()) .pipe(rename('css-manifest.json')) .pipe(gulp.dest('./release/rev'));// 记录 css 的变化 }); // 处理图片 gulp.task('image',function(){ return gulp.src(['./public/images/**/*','./uploads/*'],{base: './'}) .pipe(imagemin()) .pipe(rev()) // 修改图片名字 .pipe(gulp.dest('./release')) .pipe(rev.manifest()) .pipe(rename('image-manifest')) .pipe(gulp.dest('./release/rev')); // 记录 image 的变化 }); // 处理 js gulp.task('useref', function(){ return gulp.src('./index.html') .pipe(useref()) // 去到 index 文件中写上处理js css,实现引入的合并 .pipe(gulpif('*.js',uglify())) // 压缩操作 .pipe(gulpif('*.js',rev())) .pipe(gulp.dest('./release')) .pipe(rev.manifest()) .pipe(rename('js-manifest.json')) .pipe(gulp.dest('./release/rev')); }); // 内容替换 gulp.task('rev', ['css','image','useref'], function(){ gulp.src(['./release/rev/*.json', './release/index.html'],{base: './release'}) .pipe(revCollector()) .pipe(gulp.dest('./release')); }); // 其他任务 gulp.task('other', function(){ gulp.src(['./api/*','./public/fonts/*','./public/libs/*','./views/*.html'], {base: './release'}) .pipe(gulp.dest('./release')); }); gulp.task('default',['rev','oher']); // gulp.task('a', function(){ // cosole.log('a'); // }); // gulp.task('b', function(){ // console.log('b'); // }); gulp.task('all', ['a','b'], function(){ // all -> default console.log('all'); } ) // 在命令提示符中执行 gulp + 定义任务 指令执行任务 扩展 gulp 是一个灵活的构建工具,通过简单的配置可以帮助我们实现合并,压缩,校验,预处理等一系列人物的软件工具 常见的工具包括: Grunt Gulp F.I.S(百度出品) webpack等]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git笔记]]></title>
      <url>%2F2016%2F01%2F23%2Fgit%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[git 帮我们解决了三个主要问题 版本管理git add -&gt; git commit = 新版本 多任务开发(分支) 一个分支代表一个任务,分支之间不相互影响 git branch -&gt; git checkout -&gt; git add -&gt; git commit -&gt; 新版本 协同开发(多人共同开发) 通过共享充仓库实现 xxx.git -&gt; git init –bare (创建仓库)git push -&gt; xxx.git 上传到仓库git pull -&gt; xxx.git 从仓库下载到本地注意 一个文件想要下载仓库的版本 必须先初始化为 git 仓库 命令汇总 git config –global user.name “yourName” user.email “yourEmail” git init (在项目的根目录初始化git仓库) 创建版本 git add -&gt; git commit -&gt; 新版本 (默认添加一个master版本) 查看状态 git status git log 查看历史版本 通过分支实现多任务开发 git branch 分支名 -&gt; 切换分支 git checkout 分支名 -&gt; git add -&gt; git commit -&gt; 新版本 git checkout -b 分支名 (创建并切换至分支) git branch 查看分支 git merge 合并分支 git branch -d 删除分支 通过共享仓库实现协同开发 xx.git 的任意目录 -&gt; 进入该目录 -&gt; git init –bare 进入一个git仓库中 -&gt; git push ../xx.git master 进入另一个git仓库中 -&gt; git pull ../xx.git master xx.git 可以放到本地计算机上,但是其他开发者没有办法访问 要解决的话,需要一个专门服务器来存放xx.git共享仓库 git push user@ip:目录/xx.git master 但是并不是所有人都能熟练操作服务器,所以此种方法成本比较高 github 提供了共享仓库的功能 以表单形式就可以创建一个仓库,并且会提供仓库的地址 git push github 仓库的地址 分支名 git pull github 仓库的地址 分支名 为了免密码共享代码,可以通过ssh来实现 ssh-keygen -t sra 命令可以在本地创建公钥和私钥 将公钥的内容放到github对应账号的ssh-key下 ssh 是实现计算机间的登录 git remote add 短名字 真是名字 如何使用 git clone 仓库地址 mkdir 目录 -&gt; cd 目录 -&gt; git init -&gt; git remote add origin 仓库地址 -&gt; git pull origin master git 规范管理 不要创建过多分支 有一个”稳定分支”,即 master 分支不要轻易修改 有一个开发分支(developer),保证 master 分支的稳定性 所有的功能分支(feature)从 developer 创建 所有功能开发完成后新建发布分支(release)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[px、em和rem的区别]]></title>
      <url>%2F2016%2F01%2F21%2Fpx%E3%80%81em%E5%92%8Crem%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[px、em、rem的区别及换算方法px的特点： IE无法调整那些使用px作为单位的字体大小； 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位； Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。(引自CSS2.0手册)。 em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册)。 px与em的换算方法：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。 这里为大家提供一个网址，打开之后，根据自己的需要输入相应的数值就能一键换算： http://pxtoem.com/ em的特点： em的值并不是固定的；em会继承父级元素的字体大小。所以我们在写CSS的时候，需要注意两点： body选择器中声明Font-size=62.5%； 将你的原来的px数值除以10，然后换上em作为单位； 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。也就是避免1.2 * 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。 rem的特点： rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。下面就是一个例子： p {font-size:14px; font-size:.875rem;}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bash常用命令]]></title>
      <url>%2F2016%2F01%2F19%2Fbash%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[bash常用命令 cd: 改变目录 pwd: 查看当前目录 ls: 列出当前目录 mkdir: 创建文件目录 touch: 创建文件 cat: 查看文件全部内容 more: 或者 less 查看文件 rm: 删除文件 rm -rf: 删除文件目录 rmdir: 删除空文件目录 mv + 文件名 + 路径: 移动文件 mv + 文件名 + 重命名 或者 mv + ./文件名 + ./重命名 cp + 拷贝文件 + 路径 head -n: 查看前 n 行 tail -n: 查看后 n 行 tab: 自动补全 tab双击: 列出匹配内容 history: 列出命令记录 ssh: 远程登录 >: 重定向 >>: 重定向 并且追加 wget: 下载 tar: 解压缩 curl: 网络请求 whoami: 查看当前用户 grep: 匹配内容 vi编译器 输入 vi 进入命令模式 命令模式下: ZZ: 保存并退出 u: 撤销 dd: 删除行 yy: 复制当前行 p: 粘贴行 ctrl+f: 向上翻页 ctrl+b: 向下翻页 i: 在光标处编辑 a: 在光标后面编辑 o: 在光标下创建新行 O: 在光标上创建新行 A: 将光标移至行尾 :: 进入末行模式 在末行模式下: w: 保存 q: 退出 wq: 保存退出 e!:撤销更改 w filename: 另存为 q!: 不保存强制退出 set nu: 设置行号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[H5/C3新特性]]></title>
      <url>%2F2016%2F01%2F18%2FH5-C3%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[HTML5 新特性 语义化更好的内容标签(header,nav,section,footer,aside,article) 表单控件, calendar,date,time,email,url,search 音频、视频API(aduio,video) 画布API(canvas) 地理API(geolocation) 本地离线存储 localStorage 长期存储数据,浏览器关闭后数据不会丢失 sessionStorage 数据在浏览器关闭后自动删除 新技术 webworker,websocket,geolocation HTML5移除的元素 纯表现元素: basefont, big, center, font, s, strike, tt, u 对可用性产生负面影响的元素: frame, frameset, noframes 低版本浏览器如何支持HTML5新标签 在ie8/7/6下可以通过document.createElement方式创建新标签,可以利用这一特性支持HTML5新标签,创建好标签后还需要添加默认样式,当然更多的是采用html5shim框架: &lt;!–[if It IE 9]&gt; &lt;![endif]–&gt; CSS3 新特性 C3实现原件(border-radius),图片边框(border-image),阴影(box-shadow) 增加了更多的选择器 @font-fase特性,加载服务器或者第三方库字体 多列布局(multi-column layout) 背景属性: background-origin,backgound-clip,background-size 弹性盒子或者说伸缩盒子 线性渐变 变换效果transform: 旋转(rotete),缩放(scale),定位(translate),倾斜(skew) 过渡效果transitions:transitions-property/duration/delay/timing-function 动画效果animation 颜色 opacity,rgba,hsla 文字效果: text-shadow/overflow,word-wrap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[display属性详解]]></title>
      <url>%2F2016%2F01%2F15%2Fdisplay%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[display 属性的详解display:block block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。 block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。 block元素可以设置margin和padding属性。 display:inline inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 inline元素设置width,height属性无效。 inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display:inline-block 简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 inline-table 以表格的形式排列成行。 显示样式如下： list-item 以列表项的形式显示，类似标签。 run-in 若run-in框后面不是块级框时，run-in框本身将成为块级框 flex 弹性盒子或者说伸缩盒子 inline-block 在什么情况下用 元素变成行内元素且有块级元素的属性（width，height等）的时候用,比如说我们的logo放在a标签内时,想要a标签的宽和高能够包裹logo的话需要把a标签设置为inline-block inline-block 和 float的区别 使用inline-block：当你需要控制元素的垂直对齐跟水平排列时，使用inline-block。 使用浮动：当你需要让元素环绕某一个元素时，或者需要支持旧版本ie，或者不想处理inline-block带来的空白问题时，使用浮动。 若父元素中的图片等高，设置浮动就会工作正常。但一旦有一列图片比较高时，图片的排列就会出现问题。这是因为浮动后，图片脱离了文档流。而inline-block由于未脱离文档流，不会出现这个问题。如果你想再创建一列图片时，不会受到上一列图片inline:block的影响。而你在使用时需要时刻注意清除浮动，当内容不断变化时这很容易产生bug。另一种inline-block的适用场景：横向导航栏。通常，我们一般会设置a元素display：block然后进行浮动来制作。有时候我会直接通过对列表元素设置display:inline来制作。如果在制作中，你需要设置不同的display属性来处理浮动，那么inline-block不失为一种更好的解决方案。当你需要将元素排列成一行或者多行时，更倾向于考虑使用inline-block代替float。当然，直接使用table也是一种方法，他毕竟是专门用来处理横向与纵向排列的元素的。如果你需要创建一个很复杂的包含行列的布局，table是你的最佳选择，不过你同样也可以考虑inline-block]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS hack]]></title>
      <url>%2F2016%2F01%2F11%2FCSS-hack%2F</url>
      <content type="text"><![CDATA[css hack 概念 由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack! css hack 分类 属性前缀法(即类内部Hack)：例如 IE6能识别下划线”“和星号” “，IE7能识别星号” “，但不能识别下划线”“，IE6~IE10都认识”\9”，但firefox前述三个都不能认识。 选择器前缀法(即选择器Hack)：例如 IE6能识别html .class{}，IE7能识别+html .class{}或者*:first-child+html .class{}。 IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： ，针对IE6及以下版本： 。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。 条件注释法 只在IE下生效 只在IE6下生效 只在IE6以上版本生效 只在IE8上不生效 非IE浏览器生效 类内属性前缀法 “-″减号是IE6专有的hack “\9″ IE6/IE7/IE8/IE9/IE10都生效 “\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack “\9\0″ 只对IE9/IE10生效，是IE9/10的hack html 前缀只对IE6生效 +html +前缀只对IE7生效 @media screen\9{…}只对IE6/7生效 @media \0screen {body { background: red; }}只对IE8有效 @media \0screen\,screen\9{body { background: blue; }}只对IE6/7/8有效 @media screen\0 {body { background: green; }} 只对IE8/9/10有效 @media screen and (min-width:0\0) {body { background: gray; }} 只对IE9/10有效 @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body - { background: orange; }} 只对IE10有效- css hack 利弊 一般情况下，我们尽量避免使用CSS hack，但是有些情况为了顾及用户体验实现向下兼容，不得已才使用hack。比如由于IE8及以下版本不支持CSS3,而我们的项目页面使用了大量CSS3新属性在IE9/Firefox/Chrome下正常渲染，这种情况下如果不使用css3pie或htc或条件注释等方法时,可能就得让IE8-的专属hack出马了。使用hack虽然对页面表现的一致性有好处，但过多的滥用会造成html文档混乱不堪，增加管理和维护的负担。相信只要大家一起努力，少用、慎用hack，未来一定会促使浏览器厂商的标准越来越趋于统一，顺利过渡到标准浏览器的主流时代。抛弃那些陈旧的IE hack，必将减轻我们编码的复杂度，少做无用功。一般情况下，我们尽量避免使用CSS hack，但是有些情况为了顾及用户体验实现向下兼容，不得已才使用hack。比如由于IE8及以下版本不支持CSS3,而我们的项目页面使用了大量CSS3新属性在IE9/Firefox/Chrome下正常渲染，这种情况下如果不使用css3pie或htc或条件注释等方法时,可能就得让IE8-的专属hack出马了。使用hack虽然对页面表现的一致性有好处，但过多的滥用会造成html文档混乱不堪，增加管理和维护的负担。相信只要大家一起努力，少用、慎用hack，未来一定会促使浏览器厂商的标准越来越趋于统一，顺利过渡到标准浏览器的主流时代。抛弃那些陈旧的IE hack，必将减轻我们编码的复杂度，少做无用功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css 常见问题总结]]></title>
      <url>%2F2016%2F01%2F08%2Fcss-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[css 常见问题总结哪些css属性可以继承? 可继承: font-size font-family color ul li dl dd dt 不可继承: border padding margin width height css 有哪些选择器,优先级如何计算 id 选择器 (# myid) 类选择器 (.myclass) 标签选择器 (div) 相邻选择器 (h1+p) 子代选择器 (div&gt;p) 后代选择器 (div p) 通配符选择器 (*) 属性选择器 (div[class=”myclass”]) 伪类选择器 (a:hover, li:nth-child) css3 新增选择器 p:first-of-type p:last-of-type p:only-of-type p:only-child nth-child(2) :enabled :disabled :checked 优先级: !important &gt; 内联 &gt; id &gt; class &gt; tag 优先级就近原则,样式定义最近者为准 内联 &gt; 嵌入 &gt; link引入 以最后载入的样式为准 行内元素块元素分别有哪些 行内元素 a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体(不推荐) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码(在引用源码的时候需要) dfn - 定义字段 em - 强调 font - 字体设定(不推荐) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线(不推荐) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量 块元素 address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是 css layout的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h1 - 大标题 h2 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript - 可选脚本内容（对于不支持script的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表 DIV CSS两种盒子模型 定义: 网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 标准盒子模型/W3C盒子模型 - content-box 范围包括margin,border,padding,content 并且content不包含其他部分 IE盒子模型 - bordr-box 范围包括margin,border,paddin,content 和W3C盒子模型不同的是它的content包含了border和padding content-box和border-box的主要区别是二者的盒子的宽度是否包含元素的边框和内边距。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript面向对象篇 2]]></title>
      <url>%2F2016%2F01%2F05%2FJavascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AF%87-2%2F</url>
      <content type="text"><![CDATA[表达式的概念 广义的概念:所有返回的一段代码块,都可以成为表达式.比如: var a=0; var a, b; a = 0;这个表达式的返回值为0; b = a;这个表达式的返回值为a; 赋值表达式的返回值为=右边的值; 面向对象的概念: 一种编程思想.核心:在解决任何问题的时候,首先试图去找到一个对象来帮助解决问题. 优点: 身份:调度者; 代码的灵活度高; 可维护性高; 可扩展性高; 缺点: 可能造成代码的复杂度提高 可读性相对不好 面向过程: 身份: 执行者 顺序: 一般情况下不能打乱,从上至下一步一步执行. javascript语言的特点: 弱类型 多范式 基于对象的语言:在js中,一切都是对象 基于原形的语言 原型的概念所谓原型形就是一个函数的prototype属性所引用的对象 只要声明一个函数,那么原型就存在 function foo(){}; foo.prototype['name']='ksir'; var f = new foo(); console.log(f.constructor ===foo.prototype.constructor); 当通过该函数创建出来的每一个对象,都共享此原型,也就是说上述创建出来的所有对象可以直接访问到原型上的任何成员(属性和方法);(对象的动态特性就是对象可以同过.或者[]来动态创建对象); 原型的本质 原型的本质就是对象 function Person(name,age,gender){ this.name = name; this.age = age; this.gender = gender; this.talk = function(){ console.log('hello'); } } var kangfeng = new Person('康峰',21,'男'); var xiaoming = new Person('小明',20,'女'); var xiaohong = new Person('小红','19','女'); kangfeng.talk(); xiaoming.talk(); xiaohong.talk(); //思考:这三个儿女的talk方法是否一样? console.log(xiaoming.talk === kangfeng.talk); console.log(xiaohong.talk === xiaohong.talk): //这三个对象的方法是不一样,相互独立的 Person.prototype.addfu(){ console.log('给原型添加一个函数'); } 在构造函数中存在相同的逻辑代码,然后再创建对象的时候,会拷贝该函数中的代码逻辑,把构造函数内的方法提取出来放在一个公共的地方,这个公共的地方是该构造函数创建出来的对象都能访问,–构造函数的所有对象能够共享构造函数的原型 有点:实现同类对象的数据共享 获取原型的方式 通过函数: &lt;fnName&gt;.prototype; 通过对象: object.__proto__; //两个下划线 对象的组成部分对象本身;他的原型 每一个对象都有__proto__属性,也就是说每一个对象都有原型 Math.__proto__===object.prototype; 对象的类型就是构造函数的名字原型属性&amp;原型对象 原型属性:站在函数的角度,原型可以被称为该函数的原型属性 原型对象:站在对象的角度,原型可以被称为该对象的原型对象 __proto__这种双下划线的标准不是w3c的标准,这些属性都是非标准属性,有兼容性问题 如果我们无法通过通过双下划线获取原型属性的时候,我们就得通过函数来获取它 function getPrototype(obj){ //判断浏览器是否兼容__proto__属性 //return !!obj.__proto__? obj.__proto__:obj.constructor.prototype; if(obj.__proto__){ //支持 return obj.__proto__; }else{ //获取该对象的构造函数 //在通过此函数的prototype属性获取其原型对象 return obj.constructor.prototype; } } function A(){}; var a = A(); console.log(getPrototype(a).constructor); //如果我们的函数中有if else return结构,我们可以用3元运算符来优化. 标准构造函数的写法 //哪些属性要保存在构造函数的内部,哪些属性需要提取出来放放原型上 function B(name){}; B.prototype.name = 'tom'; var tom = new B; console.log(tome.name); var jim = new jim; console.log(jim.name); //结果都是tom //所以和具体某个对象息息相关的称为私有属性,这写属性都必须写在构造函数内,那些共享的属性(每个对象都具有的属性,不会随对象变化而变化,比如说一些方法(对象的行为)--公有属性)就可以定义在原型属性中. //一般情况下,构造函数的方法放原型上 //不提倡在js原生对象上进行扩展成员 //坏处,会导致原生对象过于庞大,累赘,影响性能 注意点 给构造函数添加方法一般添加在原型上,为了方便,一般将方法以对象的形式添加到 &lt;构造函数名&gt;.prototype{}里面,同时,不要忘了添加constructor: 构造函数名 键值对 原型的特性动态性: 给原型扩展成员会直接反应到已创建的对象身上 替换原型对象,不会反应到已创建出来的对象,但是会直接影响之后创建出来的对象 唯一性 由同一函数创建出来的所有对象,共享同一个原型对象 不可变性: 对象是无法改变原型对象上的任何成员 继承性: 所有对象都继承自它的原型对象]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决盒子塌陷的几种方法]]></title>
      <url>%2F2016%2F01%2F03%2F%E8%A7%A3%E5%86%B3%E7%9B%92%E5%AD%90%E5%A1%8C%E9%99%B7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[解决盒子塌陷的几种方案 给父盒子添加高度 给父盒子添加clear: both样式 (缺点:两个div之间的margin值失效) 内墙法 clear:after { content: ''; clear: both; display: block; height: 0; width: 0; visibility: hidden; } 给父盒子设置overflow: auto (缺点: 可能会出现滚动条)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript面向对象篇 1]]></title>
      <url>%2F2016%2F01%2F03%2FJavascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AF%87-1%2F</url>
      <content type="text"><![CDATA[表达式的概念 广义的概念:所有返回的一段代码块,都可以成为表达式.比如: var a=0; var a, b; a = 0;这个表达式的返回值为0; b = a;这个表达式的返回值为a; 赋值表达式的返回值为=右边的值; 面向对象的概念: 一种编程思想.核心:在解决任何问题的时候,首先试图去找到一个对象来帮助解决问题. 优点: 身份:调度者; 代码的灵活度高; 可维护性高; 可扩展性高; 缺点: 可能造成代码的复杂度提高 可读性相对不好 面向过程: 身份: 执行者 顺序: 一般情况下不能打乱,从上至下一步一步执行. javascript语言的特点: 弱类型 多范式 基于对象的语言:在js中,一切都是对象 基于原形的语言 原型的概念所谓原型形就是一个函数的prototype属性所引用的对象 只要声明一个函数,那么原型就存在 function foo(){}; foo.prototype['name']='ksir'; var f = new foo(); console.log(f.constructor ===foo.prototype.constructor); 当通过该函数创建出来的每一个对象,都共享此原型,也就是说上述创建出来的所有对象可以直接访问到原型上的任何成员(属性和方法);(对象的动态特性就是对象可以同过.或者[]来动态创建对象); 原型的本质 原型的本质就是对象 function Person(name,age,gender){ this.name = name; this.age = age; this.gender = gender; this.talk = function(){ console.log('hello'); } } var kangfeng = new Person('康峰',21,'男'); var xiaoming = new Person('小明',20,'女'); var xiaohong = new Person('小红','19','女'); kangfeng.talk(); xiaoming.talk(); xiaohong.talk(); //思考:这三个儿女的talk方法是否一样? console.log(xiaoming.talk === kangfeng.talk); console.log(xiaohong.talk === xiaohong.talk): //这三个对象的方法是不一样,相互独立的 Person.prototype.addfu(){ console.log('给原型添加一个函数'); } 在构造函数中存在相同的逻辑代码,然后再创建对象的时候,会拷贝该函数中的代码逻辑,把构造函数内的方法提取出来放在一个公共的地方,这个公共的地方是该构造函数创建出来的对象都能访问,–构造函数的所有对象能够共享构造函数的原型 有点:实现同类对象的数据共享 获取原型的方式 通过函数: &lt;fnName&gt;.prototype; 通过对象: object.__proto__; //两个下划线 对象的组成部分对象本身;他的原型 每一个对象都有__proto__属性,也就是说每一个对象都有原型 Math.__proto__===object.prototype; 对象的类型就是构造函数的名字原型属性&amp;原型对象 原型属性:站在函数的角度,原型可以被称为该函数的原型属性 原型对象:站在对象的角度,原型可以被称为该对象的原型对象 __proto__这种双下划线的标准不是w3c的标准,这些属性都是非标准属性,有兼容性问题 如果我们无法通过通过双下划线获取原型属性的时候,我们就得通过函数来获取它 function getPrototype(obj){ //判断浏览器是否兼容__proto__属性 //return !!obj.__proto__? obj.__proto__:obj.constructor.prototype; if(obj.__proto__){ //支持 return obj.__proto__; }else{ //获取该对象的构造函数 //在通过此函数的prototype属性获取其原型对象 return obj.constructor.prototype; } } function A(){}; var a = A(); console.log(getPrototype(a).constructor); //如果我们的函数中有if else return结构,我们可以用3元运算符来优化. 标准构造函数的写法 //哪些属性要保存在构造函数的内部,哪些属性需要提取出来放放原型上 function B(name){}; B.prototype.name = 'tom'; var tom = new B; console.log(tome.name); var jim = new jim; console.log(jim.name); //结果都是tom //所以和具体某个对象息息相关的称为私有属性,这写属性都必须写在构造函数内,那些共享的属性(每个对象都具有的属性,不会随对象变化而变化,比如说一些方法(对象的行为)--公有属性)就可以定义在原型属性中. //一般情况下,构造函数的方法放原型上 //不提倡在js原生对象上进行扩展成员 //坏处,会导致原生对象过于庞大,累赘,影响性能 注意点 给构造函数添加方法一般添加在原型上,为了方便,一般将方法以对象的形式添加到 &lt;构造函数名&gt;.prototype{}里面,同时,不要忘了添加constructor: 构造函数名 键值对 原型的特性动态性: 给原型扩展成员会直接反应到已创建的对象身上 替换原型对象,不会反应到已创建出来的对象,但是会直接影响之后创建出来的对象 唯一性 由同一函数创建出来的所有对象,共享同一个原型对象 不可变性: 对象是无法改变原型对象上的任何成员 继承性: 所有对象都继承自它的原型对象]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[盒子居中的几种方式]]></title>
      <url>%2F2015%2F12%2F20%2F%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[几种盒子居中方式 .father代表父盒子,.child代表子盒子 方式一 .father { position: relative; width: 500px; height: 500px; background-color: pink; } .child { position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 300px; height: 300px; margin: auto; background-color: #333; } 方式二 .father { display: flex; width: 500px; height: 500px; background-color: pink; } .child { width: 300px; height: 300px; margin: auto; background-color: #333; } 方式三 .father { position: relative; width: 500px; height: 500px; background-color: pink; } .child { position: absolute; top: 50%; left: 50%; width: 300px; height: 300px; margin: -150px 0 0 -150px; background-color: #333; } 方式四 .father { position: relative; width: 500px; height: 500px; background-color: pink; } .child { position: absolute; top: 50%; left: 50%; width: 300px; height: 300px; transform: translate(-50%,-50%); background-color: #333; } 方式五 .father { width: 500px; height: 500px; text-align: center; background-color: pink; } .father:after { display: inline-block; height: 100%; content: ''; vertical-align: middle; } .child { display: inline-block; width: 300px; height: 300px; vertical-align: middle; background-color: #333; } 方式六 .father { display: flex; width: 500px; height: 500px; background-color: pink; justify-content: center; align-items: center; } .child { display: table-cell; width: 300px; height: 300px; background-color: #333; } 方式七 (内容写在child盒子中) .father { display: table; width: 500px; height: 500px; background-color: pink; } .child { display: table-cell; width: 300px; height: 300px; text-align: center; vertical-align: middle; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用生成html标签的emmet语法]]></title>
      <url>%2F2015%2F12%2F15%2F%E5%B8%B8%E7%94%A8%E7%94%9F%E6%88%90html%E6%A0%87%E7%AD%BE%E7%9A%84emmet%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[常用 emmet 语法 ! 或者 doc &lt;!doctype html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; html:5 或者 ! 生成 HTML5 结构 html:xt 生成 HTML4 过渡型 html:4s 生成 HTML4 严格型 div#id 生成div的id属性 div.class 生成div的class属性 div.class&gt;ul&gt;li &lt;div class="class"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 生成兄弟: div+p+span &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; 生成上级元素 div&gt;ul&gt;li^span &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; 生成多个 ul&gt;li*5 &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 生成分组 div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; (div&gt;dl&gt;(dt+dd)*3)+footer&gt;p &lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; 生成自定义属性：a[href=”http://www.baidu.com“ title=”潜行者m 博客”] &lt;a href="http://www.baidu.com" title="潜行者m 博客"&gt;&lt;/a&gt; 生成内容编号: ul&gt;li.item$*5 &lt;ul&gt; &lt;li class="item1"&gt;&lt;/li&gt; &lt;li class="item2"&gt;&lt;/li&gt; &lt;li class="item3"&gt;&lt;/li&gt; &lt;li class="item4"&gt;&lt;/li&gt; &lt;li class="item5"&gt;&lt;/li&gt; &lt;/ul&gt; ul&gt;li.item$$$*5 生成如下结构： &lt;ul&gt; &lt;li class="item001"&gt;&lt;/li&gt; &lt;li class="item002"&gt;&lt;/li&gt; &lt;li class="item003"&gt;&lt;/li&gt; &lt;li class="item004"&gt;&lt;/li&gt; &lt;li class="item005"&gt;&lt;/li&gt; &lt;/ul&gt; ul&gt;li.item$@-*5 生成如下结构： &lt;ul&gt; &lt;li class="item5"&gt;&lt;/li&gt; &lt;li class="item4"&gt;&lt;/li&gt; &lt;li class="item3"&gt;&lt;/li&gt; &lt;li class="item2"&gt;&lt;/li&gt; &lt;li class="item1"&gt;&lt;/li&gt; &lt;/ul&gt; ul&gt;li.item$@3*5 这样就会从 3 开始排序，生成如下代码： &lt;ul&gt; &lt;li class="item3"&gt;&lt;/li&gt; &lt;li class="item4"&gt;&lt;/li&gt; &lt;li class="item5"&gt;&lt;/li&gt; &lt;li class="item6"&gt;&lt;/li&gt; &lt;li class="item7"&gt;&lt;/li&gt; &lt;/ul&gt; 配合上面倒序输出，可以这样写： ul&gt;li.item$@-3*5 生成的就是以 3 为底倒序： &lt;ul&gt; &lt;li class="item7"&gt;&lt;/li&gt; &lt;li class="item6"&gt;&lt;/li&gt; &lt;li class="item5"&gt;&lt;/li&gt; &lt;li class="item4"&gt;&lt;/li&gt; &lt;li class="item3"&gt;&lt;/li&gt; &lt;/ul&gt; 生成文本内容：a[href=”http://www.baidu.com&quot;]{点击进入百度} &lt;a href="http://www.baidu.com"&gt;点击进入百度&lt;/a&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对WEB标准及W3C的理解与认识]]></title>
      <url>%2F2015%2F12%2F10%2F%E5%AF%B9WEB%E6%A0%87%E5%87%86%E5%8F%8AW3C%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E8%AE%A4%E8%AF%86%2F</url>
      <content type="text"><![CDATA[对web标准以及W3C的理解与认识 web标准，简单来说就是将页面的结构、表现和行为各自独立实现（结构、表现和行为相分离原则）。结构主要由html标签组成，通俗来讲，写入body里的各种标签都是为了页面的结构；表现指的是css样式表，通过css样式表，可以使写入body的结构标签更具有美感；行为指的是页面和用户具有一定的交互，同时页面结构和样式会发生变化，主要由js构成。web标准一般将三部分独立分开，使它们更加模块化。但一般产生行为时，结构和表现会发生变化，这三者之间的界限就会变模糊。 W3C对web标准提出了规范化的要求，在实际编程中，包含一下几点： 对结构的要求：（标签规范可以提高搜索引擎对页面的抓取效率，对SEO很有帮助） 标签字母要小写； 标签要闭合； 标签不允许随意嵌套。 对css和js的要求： 尽量使用外联css样式表和js脚本，使结构、表现和行为分成三块，符合规范，同时提高页面渲染速度，提高用户体验； 样式尽量少用行间样式表，使结构与表现分离，标签的id和class命名要做到见文知义，标签越少，加载越快，用户体验更高，代码维护更简单，便于改版； 不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。分享：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript高级浅谈一二]]></title>
      <url>%2F2015%2F12%2F01%2FJavascript%E9%AB%98%E7%BA%A7%E7%AF%87%E6%B5%85%E8%B0%88%2F</url>
      <content type="text"><![CDATA[创建函数的方式 声明式 function foo(){ consolo.log(arguments); } foo(1,2,'3',{name:'ksir'}); 表达式 var foo = function() { console.log(arguments); }; foo(1,2,'3',{name:'ksir'}); } 构造函数 //Function(arg1,arg2,...,argN,body);所有的参数类型均为字符串 //arg1,arg2,...,argN 为可选的形参列表,表达为创建出来的函数的形参列表,数据类型字符串类型 //body 为必选参数,字符串类型,表达为:创建出来的函数的函数体部分 //var = new Function('val1','val2','return val1+val2'); var foo = new Function('return arguments[0] + arguments[1];'); console.log(foo(1)); console.log(foo); //函数也是对象 //__proto__ console.log(!!foo.__proto__); 所有的函数都是Function的实例,也就是说所有的函数的构造函数都是Function,所以所有的函数的原型对象为Function.prototype 将函数称为函数对象 其他对象称为普通对象 绘制函数的原型链 arguments对象属性 length 实参的个数 callee 返回正在执行的函数,应用在匿名函数递归调用 函数的相关属性 caller 返回调用当前函数的函数 length 形成那的个数 name 存储函数的名字 模拟函数重载 //如果函数没有传递实参,就直接打印false //如果传递一个实参,就将其直接打印出来 //如果传递两个实参,就将两个实参拼接起来,然后打印出来 //如果传递一个实参并且类型为数字的话,加1在打印 function foo(){ // console.log(arguments.length); if (arguments.length === 0) { console.log('false'); }else if(arguments.length === 1 ){ if (typeof arguments[0] === 'number') { console.log(arguments[0] + 1); }else{ console.log(arguments[0]); } }else if (arguments.length === 2 ){ console.log(arguments[0] + '' + arguments[1]); }else{ console.log('传入的参数大于2'); } } foo(); foo(1); foo('a'); foo(1,'a'); 递归调用 概念: 函数调用自身 递归调用的时候,都要加上递归调用的开始条件 function foo(){ foo(); } foo(); 实例1:求等差数列第n项的值 //第一项的值 v //等差: d //n 等差数列第n项 function foo(v,d,n){ if(n < 1 ){ return undefined; }else if( n === 1 ){ return v; }else { return foo(v,d,n -1) + d; } } foo (2,2,5); 实例2: fibonacci第n项 function fib(n){ if(n < 1){ return undefined; }else if (n === 1 || n === 2){ return 1; }else{ return fib(n - 1) + fib(n - 2) } } console.log(fib(6)); //匿名函数的递归调用 var v = (function (n){ if(n < 1){ return undefined; }else if (n === 1 || n === 2){ return 1; }else{ return arguments.callee(n - 1) + arguments.callee(n - 2) } }(8)); console.log(v); 词法作用域 规定变量的作用是由变量定义的位置决定,而不是由使用变量的位置决定,在词法作用域中,只有函数可以分割作用域,在函数内部是一个完整的作用域,与外界隔离,也就是在函数内部可以访问函数外部的数据,单函数外部无法访问内部的数据 变量名(函数名)提升 在js预解析阶段执行的操作js本身是边解析边执行的 在预解析阶段: 首先分析代码语法,如果有语法错误,就直接抛出异常,其次,将变量名以及函数名提升到当前作用域的最顶端 in 运算符 前面的属性名字须用字符串来表示,如果为变量,那么会将变量的值隐式转换成字符串,然后去判断变量的值是否为指定对象的属性(可以为继承过来的属性) 注意后面的参数必须为对象,否则会报错]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript数据类型]]></title>
      <url>%2F2015%2F11%2F13%2FJavascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[5种数据类型： 基本数据类型：Undefined、Null、Boolean、Number、String 基本类型值是指简单的数据段，5种基本类型是按值访问的，因为可以操作保存在变量中的实际值 基本类型的值在内存中占据固定大小的空间，被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。 不能给基本类型的值添加属性 引用数据类型：Object 引用类型值是指那些可以由多个值构成的对象。js不允许直接访问内存中的位置，也就是不能直接访问操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 引用类型的值是对象，保存在堆内存中，包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。 对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法 Undefined Undefined类型只有一个值，就是undefined var a &lt;=&gt; var a = undefined; 对于尚未声明过的变量，只能执行一项操作，就是使用typeof操作符检测其数据类型【但在严格模式下会导致错误】 出现场景： 已声明未赋值的变量 获取对象不存在的属性 无返回值的函数的执行结果 函数的参数没有传入 void(expression) 类型转换 Boolean(undefined)：false Number(undefined):NaN String(undefined):’undefined’ Null Null类型只有一个值，就是null,逻辑角度看，null值表示一个空对象指针 如果定义的变量将用于保存对象，最好将该变量初始化为null 实际上undefined值是派生自null值的，所以undefined == null 出现场景：对象不存在时 类型转换 Boolean(null)：false Number(null):0 String(null):’null’ 注意:null是空对象指针，而[]是空数组，{}是空对象，三者不相同注意null不能添加自定义属性 Boolean Boolean类型只有两个值：true 和 false2.出现场景： 条件语句导致系统执行的隐士类型转换 字面量或变量定义 类型转换 Number(true): 1 || Number(false) : 0 String(true):’true’ || String(false):’false’ Boolean() Boolean(undefined):false Boolean(null):false Boolean(非空对象包括空数组[]和空对象{}):true Boolean(非0): true || Boolean(0和NaN):false Boolean(非空包括空格字符串):true || Boolean(‘’):false [注意]true不一定等于1,false也不一定等于0 Number Number类型使用IEEE754格式来表示整数和浮点数值 注意:可以用一个值-0来将其转换成一个数字 三种字面量格式是十进制、八进制、十六进制 八进制字面值的第一位必须是0，然后是八进制数字序列(0-7),如果字面值中的数值超出了范围，那么前导0将被忽略，后面的数值被当作十进制数解析 八进制字面量在严格模式下是无效的，会导致js抛出错误 十六进制字面值的前两位必须是0x,后跟十六进制数字序列，字母可大写可小写 十六进制中字面值中的数值走出范围，如出现g,h等会报错 在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值 数值表示： js中可以保存正0和负0，且被认为相等 浮点数值：该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。 由于浮点型数值需要的内存空间是保存整数值的两倍，因此js会不失时机地将浮点数值转换成整数值，若小数点后没有跟任何数字或者浮点值本身表示的就是一个整数，这个数值会作为整数值来保存。 浮点数值的最高精度是17位小数 对于极大或者极小的数，可以用科学计数法e来表示的浮点数值来表示 默认情况下，js会将小数点后面带有6个0以上的浮点数值转换为以e表示法表示的数值 基于IEEE754数值的浮点计算的通病是舍入误差的问题。如：0.1+0.2 === 0.3(15个0)4 js中的数值范围是Number.MIN_VALUE(5e-324) ―― Number.MAX_VALUE(1.7976931348623157e+308) 如果超出正数范围，输出Infinity(正无穷大)，超出负数范围，输出-Infinity(负无穷大) +-Infinity不能参与数值计算 Number.MAX_VALUE+1 != Infinity,因为计算机最多保存52位尾数位，保存不了1000多位，早就失去精度，即小数位全为0，所以相加不变 Number.MIN_VALUE - 1 != -Infinity,也是同样的原因，所以结果为-1 可以用isFinite()来确定一个数值是不是有穷的,包含着隐式类型转换Number() isFinite(NaN) //false NaN NaN与任何值都不相等，包括NaN本身 任何涉及NaN的操作都会返回NaN isNaN()来判断这个数字是不是NaN,包含着隐式类型转换Number() 数值转换:Number()可用于任何类型，parseInt()和parseFloat专门用于把字符串转换成数值 注意:Number()、parseInt()、parseFloat()可以接受各种进制的数字，但对于含数字的字符串并不适用注意: Number()、parseInt()、parseFloat()中数字为1.2. 会报错，但字符串为’1.2.’则不会报错 Number() 12345678910111213Number(true):1 || Number(false):0Number(各种进制的数字)：运算后的十进制的数字，如1.0或1.或01会以1输出Number(undefined):NaNNumber(null):0Number(字符串)：Number(只包含数字的十进制和十六进制的字符串)：运算后的十进制的数字[注意]字符串中不识别八进制，按照十进制数字处理Number(&apos;&apos;和&apos; &apos;):0Number(其他情况的字符串):NaNNumber(对象)：Number([]和[0]和[-0]):0Number([数字])：运算后的数字Number([1,2]和&#123;&#125;和其他对象):NaN 2. parseInt()：在转换字符串时，会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN。如果是，则继续解析，直到解析完成或者遇到非数字字符。 - parseInt()可以识别出各种进制的整数,但在解析八进制字面量的字符串，ECMAScript3会解析八进制，但ECMAScript5没有解析八进制的能力 - parseInt()函数提供第二个参数，表示多少进制，如：parseInt(&apos;123&apos;,16或10或2) - parseInt(各种进制的数字)：运算后的十进制的数字，如1.0或1.或01会以1输出 - 因为parseInt()是专门用来处理字符串转换数字的，所以parseInt(其他类型包括&apos;&apos;)//NaN 3. parseFloat():类似于parseInt()，会忽略字符串前面的空格，直到找到第一个非空格字符 - parseFloat()只能解析十进制字符串 - parseFloat(各种进制的数字)：运算后的十进制的数字，如1.0或1.或01会以1输出 String:由单引号或双引号括起来的字符序列,任何字符串的长度都可以通过访问length属性获得 字符字面量，也叫转义序列 12345678910\n 换行\t 制表\b 空格\r 回车\f 进纸\\ 斜杠\&apos; 单引号\&quot; 双引号\xnn 以十六进制nn表示一个字符(n为0-f)，如\x41表示&apos;A&apos;\unnnn 以十六进制nnnn表示一个Unicode字符(n为0-f)，如\u03a3表示希腊字符ε ECMAScript中的字符串是不可变的 字符串连接需要先创建一个新字符串，然后在新字符串中填充两个需要拼接的字符串，最后再销毁原来的字符串。这个过程在后台发生，也是在某些旧版本浏览器(IE6)拼接字符串速度慢的原因，但后来已经解决了这个低效率问题 字符串转换 toString() Null和Undefined没有该方法 Boolean、Object、String有该方法 Number使用该方法可以传递基数2、8、10、16,如var num = 10;num.toString(2);//1010 但10.toString(2)会报错,因为数字后面不能跟标识符 String() 有toString()方法，使用toString()方法 String(null);//‘null’ String(undefined);//‘undefined’ 要把某个值转换为字符串，可以使用加号操作符把它与一个空字符串’’加在一起 如果数组中的某一项的值是null或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示最后给大家一个简单的例子说明下这五种基本类型的不同]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 笔记]]></title>
      <url>%2F2015%2F11%2F13%2FMarkdown-%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Markdown 是什么?一种轻量级的文本标记语言,通过简单的标记语法，它可以使普通文本内容具有一定的格式 Markedown 的应用场景为那些经常码字或者进行文字排版的人群设计的,包括经常需要写文档的码农,博客写手,网站小编,出版人士等等,简单的语法让你摆脱排版的烦恼,让你专注于写作,与同伴更好的写作 Markdown的优点 纯文本,兼容性好,能够用所有文本编译器打开 让你专注于写作而不是排版,提高效率 格式转换方便,markdown的文本可以转换HTML,电子书,pdf等 markdown作为一种标记语言,有极好的可读性 Markdown常用编译器OSM系统1. Atom 2. Mou 3. Typora 4. Makdown Linux系统1. Atom 2. Retext 3. Uberwriter Winddows系统1. Markpad 2. Typora 3. Rstudio 还可以在一些其他编译器上使用,比如sublime,webstorm等,不过需要自行装插件. Markdown语法标题格式 在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加 二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即 可，标题字号相应降低。例如： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 注: # 与标题之间有一个空格 演示如下: 一级标题二级标题三级标题四级标题五级标题六级标题列表格式 列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 - 就可以了， 例如： 无序列表: - 文本1 - 文本2 - 文本3 有序列表: 1. 文本1 2. 文本2 3. 文本3 注：-、1.和文本之间要保留一个字符的空格 演示如下: 文本1 文本2 文本3 文本1 文本2 文本3 链接 在 Markdown 中，插入链接不需要其他按钮，你只需要使用 [显示文本](链接 地址) 这样的语法即可，例如： [markdown](http://www.markdown.com) 演示如右: markdown 在 Markdown 中，插入图片不需要其他按钮，你只需要使用 ![](图片链接地 址)这样的语法即可，例如： ![](http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg) 演示如下: 引用格式 在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了，例如： 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂 寞。注：> 和文本之间要保留一个字符的空格。 演示如下: 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂 寞。注：&gt; 和文本之间要保留一个字符的空格。 斜体和粗体 Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。例如： *一盏灯*， 一片昏黄；**一简书**， 一杯淡茶。 守着那一份淡定， 品读属于 自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 演示如下: 一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于 自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 代码引用 需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。如果引用的语句为多行，可以将```置于这段代码的首行和末行。代码引用的案例如下：也可以用&lt;pre&gt;代替开始```和&lt;/pre&gt;代替结束``` 演示如下 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂 寞。 注：> 和文本之间要保留一个字符的空格。 表格格式:相关代码： | Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 演示如下: Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 Markdown 总结 标题 ## 标题 无序和有序列表 无序列表 - 有序列表 1 粗体和斜体 **粗体** *斜体* 链接和图片 []() ![]() 文本引用(尖括号和语义标签) &gt; 代码引用 行内引用 `` 多行引用 ```内容``` 表格 |标题1|标题2|标题2| |----|----|----| |line1|line2|line3| |a|b|c| |one|two|three| 标题1 标题2 标题2 line1 line2 line3 a b c one two three]]></content>
    </entry>

    
  
  
</search>
